# Sub-Component 3.4: Response Parser

## Purpose
Extract structured data from LLM responses, validate against schemas, handle errors, and recover from malformed outputs.

---

## Requirements Gathering

### Question 1: JSON Validation Strictness

**How strict should JSON validation be?**

Options:
- **A. Strict:** Reject any invalid JSON, trigger retry
- **B. Lenient:** Attempt auto-fix for common errors, validate fixed
- **C. Adaptive:** Strict for critical fields, lenient for optional
- **D. Repair-first:** Always attempt repair before rejecting

Considerations:
- Strict = reliable data but more retries
- Lenient = higher success rate but risk of bad data
- LLMs sometimes output "almost JSON"

### Question 2: JSON Repair Strategy

**How do we handle malformed JSON?**

Options:
- **A. Pattern-based:** Regex fixes for common issues (trailing commas, etc.)
- **B. LLM repair:** Send back to LLM with "fix this JSON" prompt
- **C. Hybrid:** Pattern fix first, LLM repair if that fails
- **D. Manual:** Flag for user to fix

Considerations:
- Pattern-based is fast but limited
- LLM repair is reliable but adds latency/cost
- Some errors may be unrecoverable

### Question 3: Partial Response Handling

**What happens when response is incomplete (cut off)?**

Options:
- **A. Discard:** Treat as error, retry entire batch
- **B. Accept partial:** Use valid portions, flag incomplete
- **C. Resume:** Send "continue from where you left off" prompt
- **D. Reduce scope:** Retry with smaller batch

Considerations:
- Context window may be exhausted
- Partial data may be better than no data
- Continuing may not align with original request

### Question 4: Raw Response Storage

**Should raw LLM responses be stored for debugging?**

Options:
- **A. Never:** Only store parsed results
- **B. On error:** Store only failed responses
- **C. Recent only:** Store last N analyses, rotate
- **D. Always:** Store all responses indefinitely

Considerations:
- Storage space (responses can be large)
- Useful for debugging and prompt improvement
- Privacy concerns (raw responses contain story content)

### Question 5: Schema Evolution

**How do we handle schema changes over time?**

Options:
- **A. Migration:** Migrate old analyses to new schema
- **B. Versioning:** Support multiple schema versions
- **C. Backward compatible:** Only additive changes
- **D. Re-analysis:** Re-run analysis when schema changes

Considerations:
- Breaking changes require migration or re-analysis
- Versioning adds complexity
- Storage space vs. correctness tradeoff

### Question 6: Response Validation Depth

**What validation should occur after parsing?**

Options:
- **A. Structural:** JSON matches schema types only
- **B. Semantic:** Values make sense (e.g., page numbers valid)
- **C. Cross-reference:** Internal references valid
- **D. All:** Structural + semantic + cross-reference

Considerations:
- Deeper validation catches more issues
- Adds processing time
- Some semantic rules may be genre-specific

---

## Technical Considerations

### Common JSON Errors

| Error | Frequency | Auto-fixable |
|-------|-----------|--------------|
| Trailing commas | High | Yes |
| Unclosed quotes | Medium | Sometimes |
| Missing braces | Medium | Sometimes |
| Comments in JSON | Low | Yes |
| Markdown code blocks | Medium | Yes |
| Single quotes vs double | Low | Yes |

### Schema Validation with Zod

```typescript
const TimelineEventSchema = z.object({
  id: z.string(),
  sequence: z.number().int().positive(),
  title: z.string().min(1).max(200),
  description: z.string().min(10).max(2000),
  pageRange: z.object({
    start: z.number().int().nonnegative(),
    end: z.number().int().nonnegative()
  }).refine(data => data.end >= data.start),
  significance: z.enum(['minor', 'moderate', 'major', 'climax']),
  confidence: z.number().min(0).max(1)
});
```

---

## Decisions Recorded

| Question | Decision | Rationale |
|----------|----------|-----------|
| 1. JSON Validation | **A. Strict** | Gemini structured output ensures valid JSON |
| 2. JSON Repair | **B. LLM repair** | Send back to LLM with "fix this JSON" prompt |
| 3. Partial Response | **A. Discard** | Retry entire batch for consistency |
| 4. Raw Storage | **D. Always** | Store all responses indefinitely for debugging |
| 5. Schema Evolution | **C. Backward compatible** | Only additive changes, no breaking changes |
| 6. Validation Depth | **D. All** | Structural + semantic + cross-reference |

### Gemini Structured Output Usage

```typescript
// Leverage Gemini's JSON mode / structured output
interface GeminiRequest {
  contents: Content[];
  generationConfig: {
    responseMimeType: 'application/json';
    responseSchema: JSONSchema;  // Gemini validates output against this
  };
}

// This ensures valid JSON, reducing need for repair
// Reference: /reference-docs/gemini-structured-output.pdf
```

### Strict Validation Pipeline

```
LLM Response
    ↓
Extract JSON
    ↓
Strict Schema Validation (Zod)
    ├── Pass → Continue
    └── Fail →
        ├── Log raw response
        └── LLM Repair Prompt
            ├── Success → Re-validate
            └── Fail → Retry entire batch
```

### LLM Repair Prompt Template

```typescript
const JSON_REPAIR_PROMPT = `
The previous response was not valid JSON.

Errors found:
{{validationErrors}}

Original response:
{{originalResponse}}

Please fix the JSON and return ONLY the corrected JSON.
Ensure it matches this schema: {{schemaDescription}}
`;
```

### Schema Versioning Strategy

```typescript
// Backward-compatible evolution only
interface AnalysisSchema {
  // v1.0 fields (required forever)
  summary: string;
  timeline: TimelineEvent[];
  characters: Character[];
  confidence: number;
  
  // v1.1 additions (optional, default provided)
  themes?: string[];
  narrativeStructure?: NarrativeStructure;
  
  // v1.2 additions (optional)
  emotionalArc?: EmotionalArc;
}

// Migration: Add defaults for new optional fields
function migrateAnalysis(analysis: any, fromVersion: string): AnalysisSchema {
  // Only adds missing fields with defaults
  // Never removes or renames fields
}
```

### Validation Layers

```typescript
async function validateResponse(response: unknown): Promise<ValidationResult> {
  // 1. Structural: Zod schema validation
  const structural = await structuralValidation(response);
  if (!structural.valid) return structural;
  
  // 2. Semantic: Values make sense
  const semantic = await semanticValidation(response);
  if (!semantic.valid) return semantic;
  
  // 3. Cross-reference: Internal consistency
  const crossRef = await crossReferenceValidation(response);
  if (!crossRef.valid) return crossRef;
  
  return { valid: true };
}
```

---

## Reference Documentation

- `/reference-docs/gemini-context-window.pdf` - Token limits and optimization
- `/reference-docs/gemini-structured-output.pdf` - JSON mode and schema validation

---

## Status: ✅ Interrogation Complete

**Next: Sub-Component 3.5 — Character Analyzer**
