# Sub-Component 3.5: Character Analyzer

## Purpose
Extract characters from analysis, resolve duplicates, map relationships, and classify narrative roles.

---

## Requirements Gathering

### Question 1: Unnamed Characters

**How should we handle unnamed characters?**

Options:
- **A. Skip:** Only track named characters
- **B. Descriptive IDs:** "red-haired-girl", "mysterious-stranger"
- **C. Generic IDs:** "character-1", "character-2"
- **D. Hybrid:** Descriptive for recurring, skip for one-off

Considerations:
- Many manga have important unnamed characters
- Descriptive IDs may not be consistent across batches
- Too many generics clutters analysis

### Question 2: Character Confidence

**How should character confidence be tracked?**

Options:
- **A. Overall only:** Single confidence for all characters
- **B. Per-character:** Each character has individual confidence
- **C. Per-attribute:** Confidence per name, role, traits
- **D. Both B+C:** Per-character + per-attribute detail

Considerations:
- Some characters clear, others ambiguous
- May want to review low-confidence characters
- Detail adds complexity

### Question 3: Name Resolution

**How do we resolve "Girl with red hair" vs "Akari" (same person)?**

Options:
- **A. Exact match:** Treat as different unless identical
- **B. Fuzzy matching:** Similar descriptions = same person
- **C. LLM deduplication:** Ask LLM if they're same
- **D. Temporal:** Same person if appears in same scene

Considerations:
- Character introduced before name revealed is common
- Fuzzy matching can have false positives
- LLM dedup adds cost but most accurate

### Question 4: Relationship Detail

**What level of relationship detail should we capture?**

Options:
- **A. Simple:** ally, enemy, family, neutral
- **B. Typed:** ally, enemy, family, love-interest, rival, mentor
- **C. Dynamic:** Include power balance, trust level, emotional closeness
- **D. Narrative:** Include relationship evolution, conflicts, history

Considerations:
- More detail = better for branch generation
- Simpler = easier for LLM to output consistently
- Evolution tracking adds complexity

### Question 5: Character Role Classification

**How granular should character roles be?**

Options:
- **A. Binary:** protagonist vs supporting
- **B. Standard:** protagonist, antagonist, supporting, minor
- **C. Archetypes:** hero, mentor, ally, herald, trickster, shadow, etc.
- **D. Functional:** Based on narrative function in specific scenes

Considerations:
- Archetypes useful for branch prediction
- Some characters change roles (ally becomes enemy)
- Functional may be too granular

### Question 6: Character Tracking Across Batches

**How do we track the same character across analysis batches?**

Options:
- **A. Name matching:** Same name = same character
- **B. Description similarity:** Fuzzy match on description
- **C. LLM identity:** Ask LLM "is this the same as [previous]?"
- **D. Position tracking:** Track by appearance location

Considerations:
- Batch overlap helps continuity
- Descriptions may vary (costume changes, etc.)
- LLM most reliable but adds cost

---

## Technical Considerations

### Character Entity Resolution

```typescript
interface CharacterResolver {
  // Find if character exists in current roster
  findMatch(
    candidate: Character,
    existingCharacters: Character[]
  ): Character | null;
  
  // Merge two character records
  mergeCharacters(
    char1: Character,
    char2: Character
  ): Character;
  
  // Calculate similarity score
  calculateSimilarity(
    char1: Character,
    char2: Character
  ): number; // 0-1
}
```

### Relationship Graph

```typescript
interface RelationshipGraph {
  nodes: Character[];
  edges: Relationship[];
  
  // Analysis queries
  findCentralCharacter(): Character;
  findFactions(): Character[][];
  findLoveTriangles(): Character[][];
  getRelationshipPath(char1: string, char2: string): Character[];
}
```

---

## Decisions Recorded

| Question | Decision | Rationale |
|----------|----------|-----------|
| 1. Unnamed Characters | **B. Descriptive IDs** | Track important unnamed characters |
| 2. Character Confidence | **D. Both per-character + per-attribute** | Maximum granularity for quality assessment |
| 3. Name Resolution | **C. LLM deduplication** | Most accurate, worth the cost |
| 4. Relationship Detail | **D. Narrative** | Full evolution, conflicts, history for branching |
| 5. Role Classification | **B + D. Standard + Functional** | Both archetype and scene-specific roles |
| 6. Cross-Batch Tracking | **C. LLM identity confirmation** | Most reliable for continuity |

### Additional Requirements

#### Historical Relationship Tracking
Character relationships change over time. Each relationship state is timestamped to the story:

```typescript
interface CharacterRelationship {
  characterA: string;
  characterB: string;
  
  // Relationship evolves over time
  timeline: RelationshipState[];
}

interface RelationshipState {
  fromEvent: string;      // Event ID when this state begins
  toEvent: string | null; // Event ID when state ends (null = current)
  
  type: RelationshipType;
  dynamic: {
    powerBalance: 'equal' | 'A_dominant' | 'B_dominant' | 'shifting';
    trustLevel: number;      // 0-1
    emotionalCloseness: number; // 0-1
    conflictLevel: number;   // 0-1
  };
  
  // Narrative tracking
  majorEvents: string[];   // Event IDs that shaped this relationship
  conflicts: Conflict[];
  evolution: string;       // How relationship got here
}
```

#### Dynamic Character Introduction
Characters can be introduced at any point in the story:

```typescript
interface Character {
  id: string;
  name: string;
  
  // Introduction tracking
  introducedAt: {
    eventId: string;
    page: number;
    context: string;  // How they're introduced
  };
  
  // Presence tracking
  activeFrom: string;  // Event ID
  activeUntil: string | null;  // Event ID (null = still active)
  
  // Can be retroactively added if missed in earlier batches
  isRetroactiveAddition: boolean;
}
```

### Character Resolution Flow

```
New Character Detected in Batch N
    ↓
Check Against Existing Characters
    ├── Exact name match → Merge
    ├── Fuzzy description match → Flag for LLM check
    └── No match → New character
    ↓
LLM Deduplication (if flagged)
    "Is 'red-haired-girl' the same as 'Akari'?"
    ↓
Update or Add to Character Roster
    ↓
Track Introduction Point
    ↓
Map Relationships (with historical states)
```

### Relationship Evolution Example

```typescript
{
  characterA: "kira-protagonist",
  characterB: "rook-ally",
  timeline: [
    {
      fromEvent: "evt_005_first-meeting",
      toEvent: "evt_012_betrayal-reveal",
      type: "ally",
      dynamic: { trustLevel: 0.8, emotionalCloseness: 0.7 },
      evolution: "Childhood friends reunited"
    },
    {
      fromEvent: "evt_012_betrayal-reveal",
      toEvent: "evt_020_reconciliation",
      type: "enemy",
      dynamic: { trustLevel: 0.1, conflictLevel: 0.9 },
      evolution: "Revealed to be Empire spy"
    },
    {
      fromEvent: "evt_020_reconciliation",
      toEvent: null,  // Current
      type: "complicated",
      dynamic: { trustLevel: 0.4, emotionalCloseness: 0.6 },
      evolution: "Working together again but trust damaged"
    }
  ]
}
```

---

## Cross-Component Note: Auto Chapter Segmentation

**This requirement belongs to Component 2 (Manga Ingestion)** — noted here for coordination:

When user uploads a folder of scanned images (entire manga), the system should:

```typescript
interface ChapterSegmentation {
  // Automatic detection
  detectChapters(images: ImageData[]): Chapter[];
  
  // Detection methods
  methods: {
    coverPageDetection: boolean;  // Detect chapter covers
    bonusArtworkDetection: boolean;  // Filter out bonus/omake
    pageNumberOCR: boolean;  // Read page numbers if present
    volumeBreakDetection: boolean;  // Detect volume boundaries
  };
}
```

**Implementation note:** Will update Component 2 spec to include this feature.

---

## Status: ✅ Interrogation Complete

**Next: Sub-Component 3.6 — Timeline Constructor**
