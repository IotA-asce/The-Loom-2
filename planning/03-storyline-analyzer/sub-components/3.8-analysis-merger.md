# Sub-Component 3.8: Analysis Merger

## Purpose
Combine multi-batch analysis results into a coherent whole, resolve batch boundary overlaps, deduplicate entities, and produce final unified output.

---

## Requirements Gathering

### Question 1: Character Merge Strategy

**How should characters appearing in multiple batches be merged?**

Options:
- **A. Simple append:** Keep all mentions, trust deduplication
- **B. Description merge:** Combine descriptions from all batches
- **C. Timeline merge:** Merge character arc across batches
- **D. Confidence-weighted:** Weight attributes by batch confidence

Considerations:
- Character may evolve (costume, personality)
- Later batches have more context
- Earlier batches may have fresh first impressions

### Question 2: Batch Overlap Handling

**How should overlapping batch regions be analyzed?**

Options:
- **A. Analyze once:** Include overlap only in first batch
- **B. Analyze twice:** Both batches analyze overlap
- **C. Deduplicate:** Analyze twice, deduplicate results
- **D. Selective:** Analyze twice, use higher confidence version

Considerations:
- Context continuity vs. double analysis cost
- Deduplication may miss nuances
- Higher confidence from more context

### Question 3: Contradiction Resolution

**How should contradictions between batch analyses be resolved?**

Options:
- **A. First wins:** First batch's version stands
- **B. Last wins:** Last batch's version overwrites
- **C. Confidence wins:** Higher confidence version wins
- **D. LLM arbitration:** Send contradiction to LLM for resolution

Considerations:
- Later batches have more story context
- Earlier batches have "first impression" accuracy
- Some contradictions may be story evolution, not errors

### Question 4: Timeline Continuity

**How should timelines from different batches be joined?**

Options:
- **A. Simple append:** Batch 1 events + Batch 2 events
- **B. Sequence renumber:** Renumber all events sequentially
- **C. Overlap merge:** Merge overlapping event regions
- **D. Gap detection:** Detect and mark gaps between batches

Considerations:
- Overlaps should merge smoothly
- Sequence numbers should be continuous
- Gaps may indicate missed events

### Question 5: Relationship Merge

**How should relationships from different batches be merged?**

Options:
- **A. Simple union:** Combine all relationship mentions
- **B. State timeline:** Merge relationship state timelines
- **C. Latest state:** Use most recent batch's relationship state
- **D. Evolution tracking:** Track relationship changes across batches

Considerations:
- Relationships evolve over story
- Earlier batches may establish relationship
- Later batches show relationship development

### Question 6: Final Output Format

**What is the final output format for downstream components?**

Options:
- **A. Flat structure:** Simple objects, easy to consume
- **B. Rich structure:** Full metadata, relationships, provenance
- **C. Queryable:** Indexed for fast lookups
- **D. Multiple views:** Different formats for different consumers

Considerations:
- Component 4 needs timeline + significance
- Component 5 needs character states + relationships
- Component 6 needs narrative style + themes

### Question 7: Provenance Tracking

**Should we track which batch contributed which information?**

Options:
- **A. None:** Final result only
- **B. Simple:** Note which batches contributed
- **C. Detailed:** Track per-entity batch provenance
- **D. Full audit:** Track every data point to source

Considerations:
- Debugging and quality assessment
- Storage overhead
- May not be needed for normal operation

---

## Technical Considerations

### Merge Pipeline

```typescript
interface AnalysisMerger {
  // Main merge function
  merge(batchResults: BatchAnalysis[]): MergedAnalysis;
  
  // Component mergers
  mergeCharacters(batches: BatchAnalysis[]): Character[];
  mergeTimeline(batches: BatchAnalysis[]): TimelineEvent[];
  mergeRelationships(batches: BatchAnalysis[]): Relationship[];
  mergeThemes(batches: BatchAnalysis[]): Theme[];
  
  // Resolution
  resolveContradictions(entities: MergableEntity[]): ResolvedEntity;
  deduplicate(entities: Entity[]): Entity[];
}
```

### Batch Result Structure

```typescript
interface BatchAnalysis {
  batchId: string;
  batchNumber: number;
  pageRange: { start: number; end: number };
  
  // Raw LLM output
  rawResponse: string;
  parsedResult: AnalysisResult;
  
  // Quality metadata
  confidence: number;
  processingTime: number;
  tokenUsage: number;
  
  // Timestamps
  startedAt: Date;
  completedAt: Date;
}

interface MergedAnalysis {
  // Unified results
  characters: MergedCharacter[];
  timeline: MergedTimelineEvent[];
  relationships: MergedRelationship[];
  themes: Theme[];
  settings: Setting[];
  summary: string;
  
  // Metadata
  mangaId: string;
  totalPages: number;
  batchCount: number;
  mergedAt: Date;
  
  // Quality
  overallConfidence: number;
  mergeIssues: MergeIssue[];
  
  // Provenance
  batchContributions: BatchContribution[];
}
```

### Contradiction Resolution

```typescript
interface Contradiction {
  entityId: string;
  entityType: 'character' | 'event' | 'relationship';
  
  // Conflicting values
  values: {
    batchId: string;
    value: unknown;
    confidence: number;
    timestamp: Date;
  }[];
  
  // Resolution
  resolutionStrategy: 'first' | 'last' | 'confidence' | 'llm_arbitration';
  resolvedValue: unknown;
  resolutionConfidence: number;
}
```

---

## Decisions Recorded

| Question | Decision | Rationale |
|----------|----------|-----------|
| 1. Character Merge | **C. Timeline merge** | Merge full character arc across batches |
| 2. Overlap Handling | **C. Deduplicate** | Analyze twice, deduplicate results |
| 3. Contradiction Resolution | **C + D. Confidence wins + LLM arbitration** | High-confidence first, LLM for close calls |
| 4. Timeline Continuity | **C + D. Overlap merge + Gap detection** | Smooth joins with gap awareness |
| 5. Relationship Merge | **D. Evolution tracking** | Track full relationship development |
| 6. Output Format | **D. Multiple views** | Optimized for each downstream component |
| 7. Provenance | **D. Full audit** | Complete traceability for debugging |

### Hybrid Contradiction Resolution

```typescript
async function resolveContradiction(
  contradiction: Contradiction
): Promise<ResolvedValue> {
  const values = contradiction.values;
  
  // Sort by confidence
  const sortedByConfidence = values.sort((a, b) => b.confidence - a.confidence);
  
  // If top confidence is significantly higher, use it
  const confidenceGap = sortedByConfidence[0].confidence - 
                        sortedByConfidence[1].confidence;
  
  if (confidenceGap > 0.2) {
    // Clear winner by confidence
    return {
      value: sortedByConfidence[0].value,
      strategy: 'confidence',
      confidence: sortedByConfidence[0].confidence
    };
  }
  
  // Close call - use LLM arbitration
  const arbitration = await llmArbitrate({
    entity: contradiction.entityId,
    options: values,
    context: 'Full story context from all batches'
  });
  
  return {
    value: arbitration.resolvedValue,
    strategy: 'llm_arbitration',
    confidence: arbitration.confidence,
    reasoning: arbitration.reasoning
  };
}
```

### Multi-View Output Generation

```typescript
interface AnalysisViews {
  // View for Anchor Event Detection (Component 4)
  anchorDetectionView: {
    timeline: TimelineEvent[];
    significanceThreshold: number;
    characterDecisions: CharacterDecision[];
    causalChains: CausalChain[];
  };
  
  // View for Branch Generation (Component 5)
  branchGenerationView: {
    characterStates: CharacterState[];
    worldState: WorldState;
    narrativeStyle: NarrativeStyle;
    relationships: Relationship[];
    alternativeOutcomes: AlternativeOutcome[];
  };
  
  // View for Story Continuation (Component 6)
  storyContinuationView: {
    recentEvents: TimelineEvent[];
    characterVoices: CharacterVoice[];
    plotThreads: PlotThread[];
    themes: Theme[];
    pacing: PacingAnalysis;
  };
  
  // Complete view for storage/display
  completeView: MergedAnalysis;
}

function generateViews(merged: MergedAnalysis): AnalysisViews {
  return {
    anchorDetectionView: generateAnchorView(merged),
    branchGenerationView: generateBranchView(merged),
    storyContinuationView: generateContinuationView(merged),
    completeView: merged
  };
}
```

### Full Audit Provenance

```typescript
interface FullAuditTrail {
  // Every data point tracked to source
  entities: Map<string, EntityProvenance>;
  
  // Merge operations logged
  operations: MergeOperation[];
  
  // Decisions recorded
  decisions: MergeDecision[];
}

interface EntityProvenance {
  entityId: string;
  entityType: string;
  
  // Source batches
  sources: {
    batchId: string;
    batchNumber: number;
    pageRange: { start: number; end: number };
    rawConfidence: number;
    extractedValue: unknown;
  }[];
  
  // Merge history
  mergeHistory: {
    operation: string;
    timestamp: Date;
    inputBatches: string[];
    resolutionStrategy: string;
    finalConfidence: number;
  }[];
  
  // Full lineage
  lineage: string; // Hash chain for integrity
}
```

### Relationship Evolution Tracking

```typescript
interface MergedRelationship {
  characterA: string;
  characterB: string;
  
  // Evolution across batches
  evolution: {
    batchId: string;
    batchNumber: number;
    state: RelationshipState;
    triggerEvents: string[];
    confidence: number;
  }[];
  
  // Consolidated timeline
  consolidatedTimeline: RelationshipState[];
  
  // Evolution summary
  summary: {
    initialState: RelationshipState;
    currentState: RelationshipState;
    keyTransitions: RelationshipTransition[];
    trajectory: 'improving' | 'deteriorating' | 'stable' | 'volatile';
  };
}
```

### Timeline Overlap Merge with Gap Detection

```typescript
function mergeTimelineWithGaps(
  batchTimelines: TimelineEvent[][]
): MergedTimeline {
  const allEvents: TimelineEvent[] = [];
  const gaps: TimelineGap[] = [];
  
  for (let i = 0; i < batchTimelines.length; i++) {
    const batch = batchTimelines[i];
    
    // Deduplicate against previous batches
    const deduplicated = deduplicateEvents(batch, allEvents);
    allEvents.push(...deduplicated);
    
    // Check for gaps between batches
    if (i > 0) {
      const previousBatch = batchTimelines[i - 1];
      const gap = detectGap(
        previousBatch[previousBatch.length - 1],
        batch[0]
      );
      
      if (gap.exists) {
        gaps.push(gap);
      }
    }
  }
  
  // Sort and renumber
  const sorted = sortBySequence(allEvents);
  const renumbered = renumberSequences(sorted);
  
  return {
    events: renumbered,
    gaps,
    continuityScore: calculateContinuity(renumbered, gaps)
  };
}
```

---

## Status: âœ… ALL SUB-COMPONENTS COMPLETE

**Component 3: Storyline Analyzer fully interrogated and specified.**
