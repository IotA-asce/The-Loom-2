# Sub-Component 6.1: Context Manager

## Purpose
Gather, maintain, and update all context needed for chapter generation — character states, world state, previous chapters, and narrative style.

---

## Requirements Gathering

### Question 1: Previous Chapter Inclusion

**How many previous chapters should be included in full vs. summarized?**

Options:
- **A. Last 1 full:** Only immediate previous chapter in full
- **B. Last 2-3 full:** Recent chapters complete, older summarized
- **C. Last 5 full:** More context, but token-heavy
- **D. All full:** Complete story always included (if fits)
- **E. Smart selection:** AI decides which chapters need full detail

Considerations:
- More context = better continuity but more tokens
- Older events may be less relevant
- Some callbacks need distant context

### Question 2: Character State Evolution

**How do we handle character state evolution naturally across chapters?**

Options:
- **A. Static states:** Character states fixed at branch point
- **B. Major events only:** Update only on significant developments
- **C. Gradual evolution:** Update incrementally each chapter
- **D. Arc-based:** Pre-plan evolution, follow arc
- **E. Reactive:** Change based on story events as they happen

Considerations:
- Characters should grow/change naturally
- But shouldn't drift from core personality
- Trauma, success, relationships change people

### Question 3: World State Changes

**Should world state change based on generated chapters?**

Options:
- **A. Static:** World stays as at branch point
- **B. Major changes only:** Only significant world shifts tracked
- **C. Dynamic:** World evolves with story
- **D. User-controlled:** User specifies what changes

Considerations:
- World should react to character actions
- Political situations shift, power dynamics change
- But hard rules (magic system) stay constant

### Question 4: Future Knowledge Retention

**How much "future knowledge" from original story should be retained?**

Options:
- **A. None:** Forget original future entirely
- **B. Loose trajectory:** Remember general direction, not specifics
- **C. Major beats:** Remember key events that should still happen
- **D. Full parallel:** Try to parallel original structure
- **E. Adaptive:** Use original as template but deviate freely

Considerations:
- Some events might still happen regardless
- But branch should feel meaningfully different
- Don't force original structure on divergent branch

### Question 5: Context Package Size

**What is the maximum acceptable context size for LLM?**

Options:
- **A. Minimal (4K tokens):** Conservative, fast
- **B. Moderate (8K tokens):** Balanced approach
- **C. Large (16K tokens):** Rich context
- **D. Very large (32K+ tokens):** Maximum context
- **E. Adaptive:** Size based on chapter complexity

Considerations:
- More context = better quality but slower/more expensive
- Gemini can handle 1M tokens
- But generation quality may degrade with too much context

### Question 6: Character Memory Management

**How do we track what each character knows/remembers?**

Options:
- **A. No tracking:** Assume characters remember everything reader knows
- **B. Major facts only:** Track only critical knowledge
- **C. Detailed knowledge base:** Track per-character knowledge
- **D. Event-based:** Derive knowledge from events witnessed
- **E. Selective emphasis:** Track only plot-relevant knowledge

Considerations:
- Characters shouldn't know what they didn't experience
- But tracking everything is complex
- Important for mystery, revelations, secrets

---

## Technical Considerations

### Context Data Structure

```typescript
interface ChapterContext {
  // Source
  branch: Branch;
  chapterNumber: number;
  
  // Previous content
  previousChapters: {
    full: Chapter[];      // Last N chapters complete
    summarized: Summary[]; // Older chapters summarized
  };
  
  // Current states
  characterStates: CharacterState[];
  worldState: WorldState;
  
  // Narrative
  style: NarrativeStyle;
  unresolvedThreads: PlotThread[];
  
  // User guidance
  userPreferences: UserPreferences;
}

interface CharacterState {
  characterId: string;
  name: string;
  
  // Core (from Component 5)
  personality: string;
  voice: string;
  
  // Current (evolving)
  emotionalState: string;
  motivations: string[];
  knowledge: string[];      // What they know
  relationships: Record<string, string>;
  development: string;      // How they've changed
  
  // History in this branch
  keyMoments: string[];     // Important events experienced
}
```

---

## Decisions Recorded

| Question | Decision | Rationale |
|----------|----------|-----------|
| 1. Previous Chapter Inclusion | **D. All full** | Leverage Gemini's 1M+ token context window per `/reference-docs/gemini-context-window.pdf` |
| 2. Character State Evolution | **E. Reactive** | Change based on story events as they happen |
| 3. World State Changes | **D. User-controlled** | User specifies what world elements change |
| 4. Future Knowledge | **D. Full parallel** | Try to parallel original story structure |
| 5. Context Package Size | **D. Very large (32K+ tokens)** | Maximize context using Gemini's capacity per reference docs |
| 6. Character Memory | **C + D. Detailed knowledge base + Event-based** | Comprehensive tracking derived from witnessed events |

### Leveraging Gemini Context Window

Per `/reference-docs/gemini-context-window.pdf`:
- Gemini 1.5 Pro: 1,000,000+ token context window
- Can include entire story (50+ chapters) in single request
- Multi-modal support for reference images if needed

```typescript
interface GeminiContextConfiguration {
  // Use maximum context capacity
  targetContextSize: 'maximum';  // 100K-500K tokens typical
  
  // Include complete story
  includeAllChapters: true;
  summarizationThreshold: null;  // Don't summarize, use full text
  
  // Leverage long-context for:
  // - Complete story continuity
  // - Deep character callbacks
  // - Complex plot thread tracking
  // - Rich world state maintenance
}
```

### Complete Story Inclusion Strategy

```typescript
interface CompleteStoryContext {
  // All chapters included in full
  allChapters: {
    sequence: number;
    title: string;
    content: string;  // Full chapter text
    wordCount: number;
  }[];
  
  // No summarization needed
  // No "recent only" limitation
  // Complete narrative available for reference
  
  // Smart indexing for retrieval
  index: {
    byCharacter: Record<string, number[]>;  // char -> chapter numbers
    byLocation: Record<string, number[]>;   // location -> chapter numbers
    byEvent: Record<string, number>;        // event -> chapter number
  };
}
```

### Reactive Character State Evolution

```typescript
interface ReactiveCharacterEvolution {
  // State changes based on story events
  evolutionType: 'reactive';
  
  // Trigger events that modify state
  stateModifiers: {
    trauma: 'emotional state change, new fears';
    success: 'confidence increase, new capabilities';
    betrayal: 'trust issues, relationship changes';
    loss: 'mourning, motivation shifts';
    discovery: 'knowledge gain, worldview changes';
    victory: 'power growth, reputation changes';
  };
  
  // Dynamic updates after each chapter
  updateAfterChapter: (chapter: Chapter) => CharacterStateUpdate;
}

// Example evolution:
// Chapter 3: Kira loses friend → Trauma modifier → Cautious, fearful
// Chapter 5: Kira wins battle → Success modifier → Confident, capable
// State evolves naturally from story events
```

### User-Controlled World State

```typescript
interface UserControlledWorldState {
  // Default: World evolves naturally
  defaultMode: 'natural';
  
  // User override options
  userControls: {
    politicalChanges: boolean;  // User approves major political shifts
    factionShifts: boolean;     // User approves faction power changes
    socialChanges: boolean;     // User approves cultural shifts
    locationChanges: boolean;   // User approves setting alterations
  };
  
  // Suggestion system
  suggestChanges: (chapter: Chapter) => WorldChangeSuggestion[];
  
  // User approves or rejects
  approveChange: (suggestion: WorldChangeSuggestion) => void;
}

// When major world change would occur:
// AI: "Kira's actions have weakened the Empire's grip on the Northern Province. 
//      Approve this world state change?"
// User: [Approve] [Modify] [Reject]
```

### Full Parallel Structure Strategy

```typescript
interface FullParallelStructure {
  // Attempt to parallel original story beats
  structureApproach: 'parallel';
  
  // Original story as template
  originalTemplate: {
    actBreaks: number[];           // Where acts change
    majorBeats: StoryBeat[];       // Key story beats
    climaxStructure: string;       // How climax builds
    resolutionType: string;        // How stories tend to resolve
  };
  
  // Adapt to branch
  adaptation: {
    mirrorBeats: boolean;          // Hit similar beats but differently
    maintainPacing: boolean;       // Similar chapter-to-chapter pacing
    preserveThemes: boolean;       // Keep thematic exploration
    allowDivergence: boolean;      // But allow meaningful differences
  };
}

// Example:
// Original: Chapter 5 = First battle, Chapter 10 = Major revelation
// Branch:   Chapter 5 = First battle (different circumstances)
//           Chapter 10 = Major revelation (different secret)
// Structure parallels but content differs
```

### Maximum Context Utilization

```typescript
interface MaximumContextConfig {
  // Per Gemini reference docs
  maxInputTokens: 1000000;  // 1M tokens
  
  // Typical usage for long story:
  typicalContextSize: {
    shortStory: '50000 tokens';    // 10 chapters
    mediumStory: '150000 tokens';  // 30 chapters
    longStory: '300000 tokens';    // 60+ chapters
  };
  
  // Still well within Gemini limits
  // Room for extensive context
  
  // Include:
  // - All previous chapters (full text)
  // - Detailed character profiles
  // - Complete world state
  // - Full narrative style guide
  // - Branch premise and trajectory
}
```

### Comprehensive Character Memory (C + D)

```typescript
interface ComprehensiveCharacterMemory {
  // C: Detailed knowledge base
  knowledgeBase: {
    facts: string[];           // What character knows
    beliefs: string[];         // What character believes
    suspicions: string[];      // What character suspects
    secrets: string[];         // What character hides
  };
  
  // D: Event-based derivation
  witnessedEvents: {
    eventId: string;
    chapter: number;
    impact: string;
    knowledgeGained: string[];
  }[];
  
  // Combined: Knowledge derived from witnessed events
  deriveKnowledge: (events: Event[]) => string[];
  
  // Validation
  shouldKnow: (fact: string) => boolean;  // Based on witness history
}

// Example:
// Event: "The spy is revealed to be Rook" (Chapter 3)
// Characters present: Kira, Rook
// 
// Knowledge Base:
// - Kira: Knows Rook is spy (witnessed)
// - Other chars: Don't know (not witnessed)
// 
// Event-based derivation ensures accurate knowledge states
```

---

## Status: ✅ Interrogation Complete

**Next: Sub-Component 6.2 — Outline Architect**
