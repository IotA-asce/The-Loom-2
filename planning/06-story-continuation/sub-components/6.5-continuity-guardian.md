# Sub-Component 6.5: Continuity Guardian

## Purpose
Validate that generated content maintains consistency with previous chapters and established facts — checking for contradictions, timeline issues, and continuity errors.

---

## Requirements Gathering

### Question 1: Validation Timing

**Should validation be real-time during generation or post-generation?**

Options:
- **A. Real-time:** Check as content is generated
- **B. Post-generation:** Check after chapter complete
- **C. Hybrid:** Light checks during, full check after
- **D. On-demand:** User requests validation
- **E. Continuous:** Background validation always running

Considerations:
- Real-time catches errors early but may slow generation
- Post-generation allows complete picture
- Balance thoroughness with performance

### Question 2: Strictness Level

**How strict should continuity be?**

Options:
- **A. Zero tolerance:** Any contradiction blocks generation
- **B. Major only:** Only block on significant errors
- **C. Tiered:** Critical/major/minor with different responses
- **D. Context-aware:** Strictness varies by error type
- **E. User-configurable:** User sets strictness level

Considerations:
- Zero tolerance may be too rigid
- But continuity errors break immersion
- Some errors are more damaging than others

### Question 3: Error Handling

**Should we auto-fix issues or flag for user review?**

Options:
- **A. Auto-fix:** AI corrects automatically
- **B. Flag only:** Mark for user to fix
- **C. Suggest fixes:** Offer corrections, user approves
- **D. Severity-based:** Auto-fix minor, flag major
- **E. Learning-based:** Learn from user's typical fixes

Considerations:
- Auto-fix fast but may change intent
- User review preserves agency
- Balance efficiency and control

### Question 4: Critical Error Types

**What types of continuity errors are most critical?**

Rank by severity:
- Character death resurrection
- Impossible timeline (character in two places)
- Contradicted established fact
- Character knowledge violation
- Changed character motivation
- Inconsistent world rule
- Timeline impossibility (effect before cause)
- Contradicted minor detail

### Question 5: Knowledge State Tracking

**How do we track what characters know/don't know?**

Options:
- **A. No tracking:** Assume omniscience
- **B. Major facts only:** Track only plot-critical knowledge
- **C. Per-character database:** Comprehensive knowledge tracking
- **D. Event-based derivation:** Calculate from witnessed events
- **E. Scene-contextual:** Check knowledge per scene

Considerations:
- Characters shouldn't know what they didn't experience
- But tracking everything is complex
- Critical for mystery, secrets, revelations

### Question 6: Cross-Chapter Callbacks

**Should we verify callbacks and references to previous chapters?**

Options:
- **A. No verification:** Trust generation
- **B. Major callbacks only:** Verify significant references
- **C. All callbacks:** Every reference checked
- **D. Consistency scoring:** Rate callback accuracy
- **E. Suggest additions:** AI suggests missing callbacks

Considerations:
- Callbacks reward attentive readers
- But too many may overwhelm
- Missed callbacks = lost continuity

---

## Technical Considerations

### Continuity Check Framework

```typescript
interface ContinuityGuardian {
  // Validation levels
  validate(
    chapter: Chapter,
    previousChapters: Chapter[],
    strictness: StrictnessLevel
  ): ContinuityReport;
  
  // Check types
  checkCharacterContinuity: () => CharacterIssue[];
  checkTimelineContinuity: () => TimelineIssue[];
  checkWorldContinuity: () => WorldIssue[];
  checkKnowledgeConsistency: () => KnowledgeIssue[];
  checkCallbackAccuracy: () => CallbackIssue[];
}

interface ContinuityIssue {
  id: string;
  severity: 'critical' | 'major' | 'minor';
  type: string;
  description: string;
  location: string;
  suggestion: string;
  autoFixable: boolean;
}
```

---

## Decisions Recorded

| Question | Decision | Rationale |
|----------|----------|-----------|
| 1. Validation Timing | **E. Continuous** | Background validation always running |
| 2. Strictness Level | **D. Context-aware** | Strictness varies by error type |
| 3. Error Handling | **C. Suggest fixes** | Offer corrections, user approves |
| 4. Error Severity Ranking | **As suggested** | Death/timeline > Facts/knowledge > Motivations/rules > Minor details |
| 5. Knowledge State Tracking | **C. Per-character database** | Comprehensive knowledge tracking |
| 6. Cross-Chapter Callbacks | **C. All callbacks** | Every reference checked |

### Continuous Background Validation

```typescript
interface ContinuousValidation {
  // Always running in background
  mode: 'continuous';
  
  // Real-time monitoring
  monitoring: {
    characterStates: 'real-time';
    timelineConsistency: 'real-time';
    knowledgeStates: 'real-time';
    worldState: 'real-time';
  };
  
  // Non-blocking
  blocking: false;
  
  // Alert on issues
  alertThreshold: 'major-or-critical';
}

// Runs alongside generation
// Flags issues as they appear
// Doesn't block creative flow
```

### Context-Aware Strictness

```typescript
interface ContextAwareStrictness {
  // Different strictness by error type
  strictnessLevels: {
    // Most critical - zero tolerance
    'character-death-resurrection': 'zero-tolerance';
    'impossible-timeline': 'zero-tolerance';
    
    // Critical - must fix
    'contradicted-established-fact': 'strict';
    'character-knowledge-violation': 'strict';
    
    // Important - should fix
    'changed-motivation': 'moderate';
    'inconsistent-world-rule': 'moderate';
    'timeline-impossibility': 'moderate';
    
    // Minor - suggest fix
    'contradicted-minor-detail': 'lenient';
  };
  
  // Context modifiers
  modifiers: {
    'early-chapter': 'more-lenient';  // Less established
    'late-chapter': 'more-strict';    // More established continuity
    'flashback': 'special-rules';     // Time-specific handling
  };
}
```

### Suggest-Fix Workflow

```typescript
interface SuggestFixWorkflow {
  // Detect issue
  detection: 'continuous-monitoring';
  
  // Generate suggestion
  suggestion: {
    description: string;
    proposedFix: string;
    reasoning: string;
  };
  
  // Present to user
  presentation: {
    highlightIssue: true;
    showSuggestion: true;
    explainReasoning: true;
  };
  
  // User decides
  userOptions: {
    accept: 'Apply suggested fix';
    modify: 'Edit fix before applying';
    reject: 'Keep as is (dismiss warning)';
    manual: 'Fix manually';
  };
}
```

### Error Severity Ranking (As Suggested)

```typescript
interface ErrorSeverityRanking {
  // Most Critical - Zero Tolerance
  mostCritical: [
    'character-death-resurrection',
    'impossible-timeline'  // Character in two places
  ];
  
  // Critical - Must Fix
  critical: [
    'contradicted-established-fact',
    'character-knowledge-violation'  // Knows what they shouldn't
  ];
  
  // Important - Should Fix
  important: [
    'changed-character-motivation',
    'inconsistent-world-rule',
    'timeline-impossibility'  // Effect before cause
  ];
  
  // Minor - Suggest Fix
  minor: [
    'contradicted-minor-detail'
  ];
}
```

### Per-Character Knowledge Database

```typescript
interface PerCharacterKnowledgeDatabase {
  // Comprehensive tracking per character
  characterKnowledge: {
    characterId: string;
    
    // Known facts
    knownFacts: {
      factId: string;
      fact: string;
      learnedIn: string;  // Chapter/scene
      confidence: 'certain' | 'suspected' | 'rumored';
    }[];
    
    // Beliefs (may be wrong)
    beliefs: string[];
    
    // Suspicions
    suspicions: {
      subject: string;
      suspicion: string;
      basis: string;  // Why they suspect
    }[];
    
    // Unknown (explicitly doesn't know)
    explicitlyUnknown: string[];
  }[];
  
  // Validation
  shouldKnow: (characterId: string, fact: string) => boolean;
  verifyKnowledge: (characterId: string, statement: string) => ValidationResult;
}
```

### All Callbacks Checked

```typescript
interface AllCallbacksChecked {
  // Verify every reference
  scope: 'all-callbacks';
  
  // Check types
  checks: {
    eventCallbacks: 'references to previous events';
    characterCallbacks: 'character history references';
    dialogueCallbacks: 'echoes of previous dialogue';
    themeCallbacks: 'recurring motifs';
    objectCallbacks: 'return of significant items';
  };
  
  // Accuracy verification
  verify: (callback: string, source: Chapter) => {
    accurate: boolean;
    accuracyScore: number;
    suggestedCorrection?: string;
  };
  
  // Suggest missing callbacks
  suggestMissing: (chapter: Chapter) => SuggestedCallback[];
}
```

---

## Status: ✅ Interrogation Complete

**Next: Sub-Component 6.6 — Chapter Refiner**
