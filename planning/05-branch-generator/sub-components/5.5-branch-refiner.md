# Sub-Component 5.5: Branch Refiner

## Purpose
Improve branch quality through iterative refinement — expanding shallow areas, deepening consequences, and enhancing narrative appeal based on feedback.

---

## Requirements Gathering

### Question 1: Refinement Trigger

**What triggers refinement?**

Options:
- **A. Low confidence:** Auto-refine if confidence < threshold
- **B. User request:** User asks to improve a branch
- **C. Pre-generation:** Set number of refinement iterations
- **D. Quality gates:** Refine until quality metrics pass
- **E. Continuous:** Always attempt one refinement pass

Considerations:
- Auto-refine adds time
- User control important for agency
- Quality gates ensure standards

### Question 2: Refinement Iterations

**How many refinement iterations should we attempt?**

Options:
- **A. Fixed:** Always exactly 2 iterations
- **B. Capped:** Up to 3 iterations, stop if no improvement
- **C. Confidence-based:** Until confidence > 0.85 or max 5
- **D. User-decided:** User specifies iteration count
- **E. Cost-aware:** Balance quality vs. token cost

Considerations:
- More iterations = better quality but slower/more expensive
- Diminishing returns after 2-3 iterations
- User may not know optimal count

### Question 3: Refinement Focus

**What aspects should refinement focus on?**

Rank by priority:
- Consequence depth (immediate effects)
- Character consistency
- World rule adherence
- Narrative appeal (interestingness)
- Long-term trajectory clarity
- Emotional impact
- Originality/uniqueness
- Pacing/tension

### Question 4: Refinement Method

**How should refinement be performed?**

Options:
- **A. Full regeneration:** Rewrite entire branch
- **B. Targeted expansion:** Expand weak sections
- **C. Layer addition:** Add depth layer by layer
- **D. Critique-based:** Have LLM critique and fix
- **E. Comparative:** Compare to original, highlight gaps

Considerations:
- Full regeneration may lose good parts
- Targeted keeps good, fixes bad
- Critique-based mimics editing process

### Question 5: User Feedback Integration

**How should user feedback be incorporated?**

Options:
- **A. Direct edit:** User edits branch directly
- **B. Instruction:** User gives instructions for refinement
- **C. Highlighting:** User highlights issues, AI fixes
- **D. Rating:** User rates aspects, AI improves low ones
- **E. Conversation:** Chat-style refinement dialogue

Considerations:
- Direct edit most control
- Instructions natural for guidance
- Chat-style most intuitive

### Question 6: Stopping Criteria

**When do we stop refining?**

Options:
- **A. Confidence threshold:** Stop at 0.9 confidence
- **B. Improvement threshold:** Stop if gain < 5%
- **C. User satisfaction:** Stop when user accepts
- **D. Cost limit:** Stop at token/cost limit
- **E. Time limit:** Stop after X seconds

Considerations:
- Multiple criteria may apply
- User satisfaction most important
- But need fallback limits

---

## Technical Considerations

### Refinement Workflow

```typescript
interface BranchRefiner {
  // Main refinement
  refine(branch: Branch, config: RefinementConfig): Promise<Branch>;
  
  // Refinement strategies
  expandConsequences(branch: Branch): Branch;
  deepenCharacterArcs(branch: Branch): Branch;
  enhanceNarrativeAppeal(branch: Branch): Branch;
  improveConsistency(branch: Branch): Branch;
}

interface RefinementConfig {
  // Trigger
  trigger: 'auto' | 'user' | 'quality-gate';
  
  // Iterations
  maxIterations: number;
  minImprovement: number;  // Stop if gain < this
  
  // Focus areas
  focusAreas: RefinementFocus[];
  
  // Method
  method: 'targeted' | 'full' | 'critique';
  
  // Stopping criteria
  targetConfidence: number;
  maxTokens: number;
  maxTime: number;
}

type RefinementFocus = 
  | 'consequences'
  | 'characters'
  | 'world'
  | 'appeal'
  | 'trajectory'
  | 'emotional-impact'
  | 'originality'
  | 'pacing';
```

---

## Decisions Recorded

| Question | Decision | Rationale |
|----------|----------|-----------|
| 1. Refinement Trigger | **B. User request** | User asks to improve a branch when they want |
| 2. Refinement Iterations | **D. User-decided** | User specifies iteration count (1-5) |
| 3. Refinement Focus | **Ranked order** | Consequence depth → Character consistency → World rules → Narrative appeal → Trajectory clarity → Emotional impact → Originality → Pacing |
| 4. Refinement Method | **D. Critique-based** | LLM critiques and fixes like an editor |
| 5. User Feedback | **B + E. Instruction + Conversation** | User gives instructions, with chat-style option |
| 6. Stopping Criteria | **C. User satisfaction** | Stop when user accepts the branch |

### User-Initiated Refinement

```typescript
interface UserInitiatedRefinement {
  // User triggers refinement
  trigger: 'user-request';
  
  // User specifies iterations
  iterations: number;  // 1-5, user choice
  
  // Entry points:
  entryPoints: {
    quickFix: 'Fix specific issue user points out';
    deepEnhancement: 'Comprehensive improvement across all areas';
    focusArea: 'Improve specific aspect only';
  };
}

// User sees branch, clicks "Refine Branch"
// → Chooses iteration count
// → Specifies focus (optional)
// → Refinement proceeds
```

### Prioritized Refinement Focus (8 Areas in Order)

```typescript
interface RefinementPriorities {
  // 1. HIGHEST: Consequence Depth
  consequenceDepth: {
    priority: 1,
    description: 'Expand immediate effects of the branch',
    focus: 'What happens in the next few scenes'
  };
  
  // 2. HIGH: Character Consistency
  characterConsistency: {
    priority: 2,
    description: 'Ensure characters act believably',
    focus: 'Actions match personality and growth'
  };
  
  // 3. HIGH: World Rule Adherence
  worldRules: {
    priority: 3,
    description: 'Maintain world consistency',
    focus: 'Magic, physics, hard rules followed'
  };
  
  // 4. MEDIUM-HIGH: Narrative Appeal
  narrativeAppeal: {
    priority: 4,
    description: 'Make branch interesting and engaging',
    focus: 'Surprising but logical developments'
  };
  
  // 5. MEDIUM: Trajectory Clarity
  trajectoryClarity: {
    priority: 5,
    description: 'Clear long-term direction',
    focus: 'Where does this branch lead'
  };
  
  // 6. MEDIUM: Emotional Impact
  emotionalImpact: {
    priority: 6,
    description: 'Strengthen emotional resonance',
    focus: 'Character feelings, reader engagement'
  };
  
  // 7. LOWER: Originality
  originality: {
    priority: 7,
    description: 'Ensure unique approach',
    focus: 'Avoid tropes, fresh perspectives'
  };
  
  // 8. LOWEST: Pacing
  pacing: {
    priority: 8,
    description: 'Optimize rhythm and tension',
    focus: 'Speed of events, dramatic beats'
  };
}
```

### Critique-Based Refinement Method

```typescript
interface CritiqueBasedRefinement {
  // Step 1: Generate critique
  critique: {
    strengths: string[];      // What's working
    weaknesses: string[];     // What needs improvement
    questions: string[];      // Ambiguities to resolve
    suggestions: string[];    // Specific improvement ideas
  };
  
  // Step 2: User reviews critique
  userReview: {
    agreesWith: string[];     // Critique points user agrees with
    disagreesWith: string[];  // Points user disputes
    priorities: string[];     // What to focus on first
  };
  
  // Step 3: Generate improvement
  improvement: {
    changes: Change[];        // Specific changes made
    reasoning: string;        // Why changes improve branch
    preserves: string[];      // What was kept from original
  };
}

// Example workflow:
// LLM: "This branch is strong on consequences but weak on 
//        emotional impact. Kira's decision feels logical but
//        we don't feel her internal conflict..."
// User: "Focus on the emotional aspect"
// LLM: [Generates improved version with deeper emotional layer]
```

### Instruction + Conversation Hybrid

```typescript
interface FeedbackIntegration {
  // Method B: Direct instruction
  instruction: {
    type: 'instruction';
    text: string;  // "Make Kira more conflicted about her choice"
  };
  
  // Method E: Conversation mode (escalation)
  conversation: {
    type: 'conversation';
    messages: Message[];
    // Back-and-forth dialogue
    // "Can you make this darker?"
    // "How about if Kira actually joins the villain?"
    // "Perfect, but make her struggle with the decision more"
  };
  
  // Mode switching
  switchToConversation: () => void;
}

// Start with instruction
// If user wants more back-and-forth, switch to conversation
```

### User Satisfaction Stopping

```typescript
interface SatisfactionBasedStopping {
  // No fixed thresholds
  automaticStop: false;
  
  // User decides when done
  stoppingCondition: 'user-accepts';
  
  // User actions:
  actions: {
    accept: 'Branch is complete, stop refining';
    continue: 'Do another refinement iteration';
    revert: 'Go back to previous version';
    compare: 'Show all versions side by side';
  };
  
  // Version history maintained
  versions: BranchVersion[];
}

// After each iteration:
// "Refinement complete. Accept this version or continue?"
// [Accept] [Continue Refining] [Compare Versions] [Revert]
```

---

## Status: ✅ Interrogation Complete

**Next: Sub-Component 5.6 — Branch Comparator**
